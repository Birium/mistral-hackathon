# Checkpoint Brainstorm — Project Manager / Knowledge Agent
*Suite de la session du 22 fév 2026 — Session 7*

---

## Ce qui s'est passé avant cette session

Les sessions 1 à 5 ont abouti à la définition complète du MVP produit.
La session 6 a archivé tout ce qui avait été délibérément mis de côté pour l'après-MVP.

Cette session 7 est née d'une analyse critique du document MVP actuel —
constat qu'il manquait de profondeur sur plusieurs points structurants.
Les décisions prises ici complètent et corrigent le MVP.
Un delta précis de ce qui doit être mis à jour dans le MVP est inclus à la fin.

---

## Décisions prises dans cette session

### 1. L'autonomie de l'agent — pas de flow end-to-end rigide à spécifier

Le flow exact de l'agent n'a pas à être tracé pas à pas dans le MVP,
ni dans aucun document de spécification produit.
Le principe est le suivant : l'agent reçoit un contexte initial riche
(overview, tree.md, profile.md), un gros system prompt qui lui explique
l'architecture du vault, ses conventions, son rôle, et les tools disponibles.
À partir de là, c'est lui qui navigue, cherche, décide, et agit.

Le vault est une structure répétable et connue — l'agent sait ce que contient
chaque type de fichier, où chercher en fonction de la nature de l'information,
comment interpréter ce qu'il trouve. C'est la promesse du design :
un environnement suffisamment structuré pour qu'un agent intelligent
n'ait pas besoin qu'on lui décrive chaque étape.

Le system prompt est donc un composant à part entière du système.
Il n'est pas de l'implémentation technique — c'est le contrat entre
le développeur et l'agent. Le MVP doit l'identifier comme tel,
sans nécessairement en rédiger le contenu.

---

### 2. Le format de sortie du search — architecture finale

C'est la décision nouvelle la plus structurante de cette session.
Elle remplace ce que le MVP actuel décrit comme "une synthèse en Markdown."

La sortie du search est composée de deux parties distinctes, dans l'ordre suivant :

**Partie 1 — L'overview de l'agent.**
Quelques lignes rédigées par l'agent de search au terme de son exploration.
Il résume ce qu'il a trouvé, dans quels projets ou fichiers, et en quoi
c'est pertinent par rapport à la question posée. Ce n'est pas une synthèse
profonde — c'est une orientation. Deux à cinq lignes suffisent.
Cette partie est produite par le LLM, pas par l'engine.

**Partie 2 — Les fichiers concaténés.**
L'agent spécifie les fichiers et sections pertinents qu'il a identifiés
pendant son exploration. Un engine mécanique — pas un LLM —
les assemble dans un document markdown structuré.
Chaque bloc est préfixé par le path du fichier concerné.
Si una section spécifique a été ciblée, la range de lignes est indiquée.

Le format de sortie ressemble à :

```
[overview rédigée par l'agent]

---

## projects/startup-x/state.md

[contenu complet du fichier]

## projects/startup-x/changelog.md (lines 1-45)

[contenu des lignes 1 à 45]

## vault/tasks.md

[contenu complet du fichier]
```

L'adressage se fait par fichier complet ou par range de lignes.
Pas d'adressage par header markdown pour l'instant — les lignes sont
suffisantes pour le MVP et triviales à implémenter.
L'adressage par header est une amélioration future possible.

Ce format est identique pour le MCP et pour l'interface web.
Un layer de différenciation entre les deux contextes est une feature post-MVP.

---

### 3. Le toggle des modes du chat input

Le switch entre les trois modes — update, search, answering —
se fait via un toggle explicite dans l'interface.
Ce n'est pas de la détection automatique d'intention.

Le mode answering est la seule exception :
il est sélectionné automatiquement quand l'utilisateur clique
sur "Répondre" depuis un item inbox dans la vue inbox.
Dans ce cas, un bandeau au-dessus du champ rappelle
à quel item inbox la réponse est liée.

---

### 4. L'état initial du vault au premier lancement

Le vault est pré-créé au premier lancement.
L'utilisateur ne démarre pas dans le vide.

Ce qui existe à l'initialisation :
les dossiers vides `inbox/`, `bucket/`, `projects/`,
et les fichiers racine `overview.md`, `tree.md`, `profile.md`,
`tasks.md`, `changelog.md`.

Ces fichiers contiennent du contenu commenté qui explique leur rôle —
du type "ce fichier est le profile de l'utilisateur, il contient ses préférences
durables, ses contraintes récurrentes, son style de travail."
Ce n'est pas un wizard d'onboarding. C'est un vault déjà structuré,
avec des fichiers qui savent à quoi ils servent.

---

### 5. Le processing pipeline — scope et emplacement

Le pipeline de transformation des fichiers entrants vit dans le backend,
en amont de la queue, avant que quoi que ce soit n'arrive à l'agent.

Au lancement du MVP : texte et images uniquement.
Le texte passe tel quel. Les images passent telles quelles au modèle vision.

Les PDFs sont le premier fast-follow post-MVP.
Quand intégrés, ils passent par une lib de conversion PDF-to-markdown
dans ce même pipeline. À l'entrée du système, tout sera toujours
soit du texte, soit une image — c'est l'invariant du système.

---

### 6. Le edit tool — pattern search-replace

Le edit tool suit le pattern search-replace déjà implémenté dans Voltaire.
L'agent donne le texte original exact à trouver dans le fichier,
puis le texte de remplacement. Le tool localise la première occurrence
du texte original et le remplace.

Ce mécanisme est connu de l'équipe, le code source de Voltaire
sert de référence directe. Pas besoin de le réinventer.

---

### 7. La vue activité — full mock pour le MVP

Il n'y a pas de streaming, pas de WebSocket, pas d'étapes en temps réel.
Le frontend envoie la requête, affiche un état de chargement,
et attend la réponse complète du backend.

Quand la réponse arrive :
pour un update, le micro-résumé de l'agent s'affiche avec une confirmation
et la liste des fichiers touchés.
Pour un search, l'overview de l'agent s'affiche suivie des fichiers concaténés.

Le streaming WebSocket en temps réel est identifié comme amélioration post-MVP.

---

### 8. Le compteur inbox — tracker programmatique

Le badge numérique sur l'icône inbox dans la sidebar
n'est pas maintenu par l'agent.
C'est un tracker programmatique qui observe la file structure —
il compte le nombre de folders présents dans `inbox/`
et met à jour le badge automatiquement à chaque ajout ou suppression.
Même mécanique que le file watcher qui gère le re-render du file tree.

---

### 9. La distinction tree.md vs tool tree()

Ces deux éléments ont des rôles distincts et non redondants.

`tree.md` est le fichier chargé dans le contexte initial de chaque agent
au démarrage d'une session, aux côtés de `overview.md` et `profile.md`.
Il donne à l'agent la carte complète du vault avant qu'il commence à agir.
Il n'est jamais appelé comme outil — il est simplement là, en contexte.

Le tool `tree()` est un outil dynamique que l'agent appelle pendantson raisonnement
quand il veut explorer un dossier spécifique plus en détail —
déplier le bucket d'un projet, vérifier le contenu d'un dossier inbox,
examiner la structure interne d'un projet qu'il envisage de modifier.
C'est la loupe, pas la carte.

---

### 10. Structure documentaire — MVP et TECHNICAL.md séparés

Le MVP couvre les décisions produit : quelles features, quels comportements,
quelles boundaries, quel scope, quels composants et leurs rôles conceptuels.
Quelqu'un qui lit le MVP comprend ce qu'on construit et comment
les pièces s'articulent — sans savoir comment l'implémenter.

Un document séparé — `TECHNICAL.md` — couvrira les décisions d'implémentation :
la configuration QMD et sa stratégie de chunking, les librairies retenues,
l'architecture exacte du service backend, la structure des modules,
comment MCP et HTTP coexistent dans le même process, etc.

Ce qui appartient clairement au MVP et non au TECHNICAL.md :
le concat engine comme composant identifié, le system prompt comme concept,
le processing pipeline comme étape du flux, le toggle des modes comme décision UI.

---

## Ce qui doit être mis à jour dans le MVP

Cette section liste précisément les modifications à apporter au document MVP actuel,
organisées par impact.

**Réécrire la section sur la sortie du search agent.**
Le MVP actuel dit "synthétise une réponse en Markdown."
Ce n'est plus ça. La sortie est composée d'une overview rédigée par l'agent
suivie de fichiers concaténés par l'engine mécanique.
Le concat engine doit être décrit comme un composant à part entière :
ce qu'il fait, ce qu'il reçoit (liste de fichiers avec ou sans range de lignes),
ce qu'il retourne (document markdown avec path headers).

**Ajouter une section sur le system prompt.**
Identifier le system prompt comme composant produit de chaque agent.
Il contient la compréhension de l'architecture du vault, le rôle de l'agent,
les conventions des fichiers, les tools disponibles et leur usage.
C'est ce qui permet à l'agent d'être autonome. Pas besoin d'en rédiger
le contenu dans le MVP — juste d'identifier son existence et son rôle.

**Préciser le mécanisme des modes du chat input.**
Ajouter que le switch update/search est un toggle explicite dans l'UI.
Ajouter que le mode answering est auto-sélectionné depuis la vue inbox.

**Ajouter une section sur l'initialisation du vault.**
Décrire l'état du vault au premier lancement : dossiers pré-créés,
fichiers racine existants avec contenu commenté expliquant leur rôle.

**Préciser le scope et l'emplacement du processing pipeline.**
Indiquer qu'il vit dans le backend avant la queue.
Préciser que le MVP supporte texte et images uniquement au lancement,
et lister les PDFs comme fast-follow post-MVP avec une phrase sur
l'ajout de la lib de conversion dans ce pipeline.

**Clarifier la vue activité.**
Indiquer explicitement qu'elle est full mock pour le MVP :
pas de streaming, pas de WebSocket, juste un loader suivi du résultat complet.
Identifier le streaming WebSocket en temps réel comme amélioration post-MVP.

**Préciser le compteur inbox.**
Ajouter que le badge est maintenu par un tracker programmatique
qui observe la file structure — pas par l'agent.

**Clarifier la distinction tree.md vs tool tree().**
Ajouter une phrase dans la description de chacun pour que leur
complémentarité soit explicite : tree.md est le contexte initial,
tree() est l'outil dynamique d'exploration en cours de session.

**Préciser le edit tool.**
Mentionner le pattern search-replace : l'agent fournit le texte original exact
et le texte de remplacement. Référencer Voltaire comme source de l'implémentation.

**Ajouter une note sur la structure documentaire.**
Une phrase dans le MVP indiquant que les détails d'implémentation
(configuration QMD, stack technique précise, structure des modules)
sont documentés dans `TECHNICAL.md`.

---

## Ce qui reste inchangé depuis les sessions précédentes

L'intégralité de ce qui était tranché dans les sessions 1 à 6 reste valide.
Cette session complète et précise — elle ne révise rien de fondamental.