# Checkpoint Brainstorm — Project Manager / Knowledge Agent
*Suite de la session du 22 fév 2026 — Session 5*

---

## Ce qui a changé par rapport aux sessions précédentes

Ce document est la suite directe des quatre premiers brainstormings. Tout ce qui était tranché reste tranché. Ce document capture uniquement les évolutions, nouveaux éléments, et décisions prises dans cette session. Les cinq documents ensemble forment la spec complète.

---

## Décisions prises dans cette session

### 1. Le mécanisme de notification inbox — le plus simple possible

Le canal de notification, c'est Discord ou Telegram — celui qui est le plus rapide à brancher. Pas d'email pour l'instant, trop de plomberie pour pas grand chose. Le principe est simple : quand l'agent crée un item dans l'inbox, il envoie une notification sur le canal configuré. Cette notification contient le contenu du `review.md` — le raisonnement de l'agent et sa question — et les fichiers d'input originaux en pièces jointes si c'est pertinent.

Quand l'utilisateur répond sur ce canal, sa réponse est captée et envoyée à la route `update` du système, exactement comme n'importe quel autre input. Ce qui la distingue d'un update ordinaire, c'est une metadata : `inbox_ref`, qui contient le path du folder inbox concerné — par exemple `inbox/2025-07-14-vocal-meeting`. L'agent de maintenance voit cette metadata, sait qu'il s'agit d'une réponse à un item inbox en attente, lit le folder correspondant, et traite le routing avec la réponse de l'utilisateur en contexte.

Si après cette réponse l'ambiguïté subsiste, l'agent met à jour le `review.md` avec les nouveaux éléments et renvoie une nouvelle notification. Le folder inbox reste ouvert, le thread continue dans le même `review.md`. Ce n'est pas une limitation — c'est le design. Le folder est un thread de résolution, pas un ticket one-shot.

---

### 2. Le contenu du `review.md` — le raisonnement rendu visible

C'est un point de design critique. Un `review.md` qui dit "je ne sais pas où ranger ça" est inutile. L'utilisateur ne peut pas répondre à quelque chose d'aussi vague, et ça crée de la friction au lieu d'en réduire.

Le `review.md` doit exposer le travail de l'agent — ce qu'il a cherché, dans quels projets il est allé, ce qu'il a trouvé ou pas trouvé, et pourquoi ça ne lui a pas permis de router. L'utilisateur lit ça et comprend immédiatement ce que l'agent a essayé. Il peut corriger une mauvaise direction, confirmer une hypothèse, ou simplement dire "c'est un nouveau projet, crée-le". Ce n'est pas l'utilisateur qui doit expliquer depuis zéro — c'est l'agent qui expose son raisonnement incomplet et l'utilisateur qui le complète.

Un exemple de ce que ça ressemble en pratique : "J'ai trouvé une mention d'un client dans ce vocal et j'ai cherché dans startup-x, mais aucun client ne correspond à ce nom. J'ai aussi repéré une référence à un appartement rue de Rivoli — j'ai cherché dans tous tes projets actifs et je n'ai pas de projet lié à une recherche d'appartement. Soit c'est un projet qui n'existe pas encore, soit je rate quelque chose. Deux pistes : tâche globale + nouveau projet appart-search, ou c'est lié à un contexte que je ne connais pas encore."

---

### 3. La structure de l'inbox — des folders, pas des files

L'inbox n'est pas un folder de fichiers à plat. C'est un folder de folders. Chaque item en attente de résolution est un folder indépendant.

```
inbox/
├── 2025-07-14-vocal-meeting-client/
│   ├── review.md
│   └── transcript-vocal.md
│
└── 2025-07-15-email-specs-nouveau-projet/
    ├── review.md
    ├── email-specs.md
    └── screenshot-attached.png
```

Chaque folder porte un nom qui suit le pattern `date-description-courte`, généré par l'agent au moment de la création. Suffisamment descriptif pour qu'un coup d'œil sur le tree permette de comprendre ce qui traîne dans l'inbox sans ouvrir chaque folder.

À l'intérieur, deux types de contenu. Les fichiers d'input originaux — tels qu'ils ont été reçus, avec des noms descriptifs donnés par l'agent. Texte, images, peu importe ce qui était dans l'update d'origine. Et `review.md`, le seul fichier que le système gère activement — il contient le raisonnement de l'agent, ce qui a été cherché, ce qui manque, et la question posée à l'utilisateur. Si le thread de résolution nécessite plusieurs échanges, le `review.md` est mis à jour à chaque passe. Le folder reste le même, les fichiers d'input restent intacts, seul le `review.md` évolue.

Quand l'item est résolu, l'agent route les fichiers vers leur destination dans le vault, log l'opération dans le changelog global, et supprime le folder inbox entier. Rien ne reste.

---

### 4. La confirmation de la maintenance — le changelog global, rien d'autre

Il n'y a pas de notification envoyée à l'utilisateur pour les opérations de maintenance de routine. La confirmation, c'est le changelog global. À chaque fois que l'agent de maintenance touche des fichiers, il ajoute une entrée dans `changelog.md` qui décrit ce qui a été fait — une entrée par opération de maintenance, pas par fichier touché. Si une opération met à jour le state d'un projet, ajoute une tâche, et crée un item bucket, c'est une seule entrée qui résume l'ensemble.

C'est pull, pas push. L'utilisateur qui veut savoir ce que le système a fait ouvre le changelog. Le jour où il y a une UI, ce changelog devient un feed visible. Pour l'instant c'est un fichier, et c'est suffisant. La seule chose qui génère une notification push, c'est l'inbox — parce que c'est le seul point du système qui nécessite une intervention active de l'utilisateur.

---

### 5. Le processing asynchrone et la queue

La route `update` du MCP retourne immédiatement un acknowledgment — `{ status: "accepted", id: "update-xyz" }` — et le processing réel se fait en background. L'appelant ne bloque pas, il continue son travail. C'est non-négociable pour que le système soit utilisable depuis un agent externe qui ne veut pas attendre que la maintenance soit terminée pour continuer.

Pour garantir la cohérence du vault, les updates sont traitées séquentiellement via une queue. Une update ne commence pas son processing tant que la précédente n'est pas terminée. Deux agents de maintenance en parallèle qui écrivent dans les mêmes fichiers créeraient des conflits impossibles à résoudre proprement. La queue évite ça de façon triviale.

Comme c'est un usage personnel avec quelques updates par heure au maximum, une queue in-memory simple est suffisante. Pas de Redis, pas d'infrastructure de queue distribuée. Le truc le plus simple qui marche. La complexité peut grandir si le besoin se fait sentir concrètement, pas avant.

Les opérations de search, elles, peuvent tourner en parallèle sans restriction. Elles sont read-only, elles ne modifient rien, elles ne créent pas de risques de conflit. Un search qui tourne pendant qu'un update est en cours de processing lira les fichiers dans leur état au moment de la requête — potentiellement avant qu'une mise à jour soit complète — mais c'est acceptable. On ne cherche pas de la consistance transactionnelle, on cherche de la mémoire humaine.

---

### 6. L'agent de maintenance — même architecture que le search agent

L'agent de maintenance et le search agent partagent la même structure fondamentale. Même système de tools — read, write, edit, append, delete, move, tree, search. Même approche du system prompt — l'agent comprend l'architecture du vault, sait naviguer la structure, planifie avant d'agir. La différence est dans la tâche et dans les permissions : le search agent est read-only, le maintenance agent lit et écrit.

Ce qui caractérise le maintenance agent, c'est son mode de raisonnement : il se demande en permanence "est-ce que l'arborescence reflète encore la réalité ?" Il commence par lire l'overview et le tree pour comprendre l'état global, il cherche dans le vault avant d'écrire pour vérifier si une information existe déjà ou contredit quelque chose, il prend ses décisions de routing et de mise à jour, il délègue la génération de contenu markdown au worker quand c'est nécessaire, et il log ses actions dans le changelog global avant de terminer.

---

## Ce qui est maintenant tranché — résumé express

| Sujet | Décision |
|---|---|
| Canal de notification inbox | Discord ou Telegram — le plus simple à brancher |
| Reply de l'utilisateur | Via route `update` avec metadata `inbox_ref: <folder-path>` |
| Contenu du review.md | Raisonnement complet de l'agent — ce qui a été cherché, pas trouvé, et pourquoi |
| Thread inbox multi-échanges | review.md mis à jour à chaque passe — même folder jusqu'à résolution |
| Structure inbox | Folders, pas files — un folder par item |
| Contenu d'un folder inbox | Fichiers d'input originaux + review.md |
| Naming des folders inbox | `date-description-courte` généré par l'agent |
| Clôture d'un item inbox | Routing des fichiers + log changelog + suppression du folder entier |
| Confirmation de maintenance | Changelog global uniquement — pas de push notification de routine |
| Granularité du log changelog | Une entrée par opération de maintenance, pas par fichier touché |
| Route update | Retourne un acknowledgment immédiat — processing en background |
| Queue des updates | In-memory, séquentielle, la plus simple possible |
| Parallélisme search | Autorisé — read-only, pas de risque de conflit |
| Architecture maintenance agent | Identique au search agent — même tools, même structure de raisonnement, tâche différente |

---

## Questions ouvertes — mise à jour

**Le flow end-to-end du maintenance agent** reste formellement non tracé de façon exhaustive. Les éléments sont tous posés — les tools, la structure de raisonnement, l'ordre d'opération, la queue, le log changelog — mais un tracé complet "input reçu → acknowledgment → processing → tous les fichiers mis à jour → entrée changelog" avec les cas limites n'a pas encore été fait. Toujours prioritaire pour une session future si nécessaire avant l'implémentation.

**Le code execution tool** reste identifié comme path d'optimisation future, non-prioritaire pour le MVP.

**L'interface, le MCP en cloud, et les intégrations avancées** restent des sujets post-MVP.

---

*La structure du vault, les deux agents, les tools, le search, le routing, le bucket, l'inbox, la queue, et la confirmation sont maintenant tous définis. Les cinq sessions forment une spec complète.*