# Checkpoint Brainstorm — Project Manager / Knowledge Agent
*Session du 22 feb 2026 — À reprendre ici*

---

## Le Problème qu'on résout

L'information projet est explosée partout. Mails, Excel, Google Docs, WhatsApp,
Notion, post-its. L'utilisateur est le seul dépositaire de la connaissance
complète. Il oublie. Il ne priorise pas bien. Il passe un temps fou à essayer
de centraliser — et deux semaines plus tard tout est à nouveau éparpillé.

Quand il essaie d'utiliser l'IA, il doit tout réexpliquer depuis le début.
Il oublie des éléments clés. Il biaise. Il perd 80% de la complexité dans
la traduction. La plupart des gens ne savent même pas quelles informations
sont importantes à donner. Résultat : réponses génériques, conversations qui
partent en vrille, friction énorme.

Le document de référence qu'on se fait au début ? Outdated en 48 heures.
Parce qu'une seule spec qui change juste un tout petit peu peut faire s'effondrer
une partie entière du projet et rendre obsolètes 3 décisions précédentes.

Avec plusieurs projets en parallèle, la charge mentale explose.

**Ce qu'on veut** : un assistant qui connaît réellement tes projets dans toute
leur complexité, qui maintient cette connaissance automatiquement sans effort
de ta part, et qui peut te donner de vrais conseils contextualisés.
La référence : Jarvis. Tu parles, il intègre, il maintient, il structure.

---

## Ce qu'on construit

Un **Knowledge Agent** dont le travail est de maintenir une arborescence de
fichiers markdown structurée qui représente la totalité de la connaissance
projet de l'utilisateur.

L'interface, la voix, le chat, les intégrations MCP — ce sont des portes
d'entrée et de sortie sur cette arborescence. Rien de plus.
Le cœur, c'est le file tree et les agents qui le maintiennent.

Ce n'est pas un concurrent de ChatGPT, Perplexity ou Gemini. Ces outils font
des tâches ponctuelles très bien. Ce qu'on construit, c'est l'endroit où tout
vit, se structure, et se maintient. Ton espace personnel. Ton Drive intelligent.
Quelque chose comme 1Password mais pour tous tes projets.

---

## L'Architecture : Deux Agents Distincts

### L'Agent de Maintenance
Son contexte mental : *"Est-ce que cette arborescence reflète encore la réalité ?"*

Il lit et il écrit. Quand une nouvelle information arrive, il ne fait pas que
l'ajouter — il vérifie la cohérence de tout ce qui existe déjà. Il déprécie.
Il met à jour. Il restructure si nécessaire. Il route les données vers les bons
fichiers. Il traite les items de l'inbox. Il met à jour l'overview.

Il travaille avec un **edit tool chirurgical** — il n'écrit jamais un fichier
entier depuis zéro sauf si le fichier est court ou nécessite une réécriture
totale (ex: `description.md` qui change de vision). Pour tout le reste, il
édite des sections précises à des endroits précis. C'est la condition pour
que le système soit économique en tokens et viable à l'échelle.

### L'Agent de Search
Son contexte mental : *"Qu'est-ce que l'utilisateur a besoin de savoir ?"*

Il lit seulement. Il ne touche à rien. Il traverse le file tree, connecte
des informations entre elles, les assemble, les synthétise. Il répond à des
questions, trouve des informations, construit du contexte.

### Ce qu'ils partagent
Les deux agents opèrent sur le même file tree. Ils lisent les mêmes fichiers.
Ils partagent beaucoup d'informations communes — mais leurs modes de pensée,
leurs outils, et leurs outputs sont fondamentalement différents.

### Sur les modèles et les context windows
Les modèles pas chers et rapides avec 120-130k de context window sont parfaits
pour ces deux agents. Ces tâches ne sont pas de la génération de code technique
et syntaxiquement précise — ce sont des tâches de routing, de compréhension
sémantique, de maintenance de connaissance. À 120-130k tokens, ces modèles
savent naviguer dans de grosses structures. Le budget token est confortable :
on peut charger overview + state + changelog + tasks d'un projet d'un coup
pour une opération de maintenance sans stress.

---

## La Structure du File Tree — Validée

```
vault/
├── overview.md
├── profile.md
├── tasks.md
├── changelog.md
├── inbox/
├── bucket/
│   ├── vocal-2025-07-14-meeting-client.md
│   ├── email-2025-07-12-specs-v2.md
│   └── screenshot-2025-07-10-review.md
│
└── projects/
    └── startup-x/
        ├── description.md
        ├── state.md
        ├── tasks.md
        └── changelog.md
```

---

## Détail de Chaque Fichier

### `overview.md` — Le Dashboard Vivant

**Rôle** : photo instantanée du système entier à haut niveau. C'est le premier
fichier que les deux agents lisent. Le search agent l'utilise pour savoir où
chercher. Le maintenance agent l'utilise pour comprendre l'état global avant
d'agir.

**Format** : 50-80 lignes maximum. Sections claires et adressables. Réécrit
entièrement par le maintenance agent lors de changements significatifs — pas
appendé.

**Contenu type** :
- Contexte de vie (ex: "Part aux US le 22 fév pour 2 mois, remote pendant")
- Focus actuel — sur quoi on travaille là maintenant
- Projets actifs avec statut en une ligne chacun
- Projets en pause
- Idées / intentions pré-projet (ex: "envie de faire du vlog, pas encore démarré")
- Items en attente dans l'inbox (count + description brève)

**Pourquoi c'est important** : avec 25, 45 projets en parallèle, on ne lit
pas 45 `state.md`. On lit l'overview. C'est l'index vivant de tout.
C'est aussi là que vivent les informations de contexte de vie qui impactent
tout sans appartenir à un projet précis — un voyage prévu, un changement de
situation, une contrainte temporaire.

---

### `profile.md` — L'Identité Utilisateur

**Rôle** : tout ce qui est stable et durable sur l'utilisateur. Préférences,
habitudes de travail, contraintes récurrentes, contexte personnel. Ce fichier
est mis à jour lentement et évolue au fil du temps via les interactions.

**Contenu type** :
- Préférences de travail et de communication
- Contraintes récurrentes (fuseau horaire, organisation de la semaine)
- Informations d'identité utiles pour contextualiser les réponses
- Préférences de format, de style

**Distinction avec overview.md** : profile.md capture ce qui EST vrai sur
l'utilisateur de façon durable. overview.md capture ce qui SE PASSE maintenant.
Le voyage aux US début février va dans overview.md (temporaire). "Préfère les
réponses directes sans blabla" va dans profile.md (durable).

---

### `tasks.md` (global) — Les Tâches Orphelines

**Rôle** : tâches qui ne sont liées à aucun projet existant. Tâches en attente
d'un projet, tâches cross-projet, ou tâches trop petites pour justifier un
projet.

**Format** : un seul fichier (pas un dossier de fichiers — ça serait too much).
Sections par statut avec entrées structurées. Format prévisible avec des ancres
claires pour que le maintenance agent puisse éditer chirurgicalement.

**Format d'entrée type** :
```markdown
## En cours
- Appeler le comptable pour TVA Q3 | prio:haute | ajoutée:2025-07-14

## À faire
- Rechercher prestataire design | prio:moyenne | ajoutée:2025-07-10

## Fait
- ~~Renouveler abonnement serveur~~ | fait:2025-07-13
```

**Évolution possible** : une tâche globale peut être promue en projet si elle
grossit. Le maintenance agent gère cette transition.

---

### `changelog.md` (global) — Événements et Décisions Non-Projet

**Rôle** : capturer tous les événements, décisions, et évolutions qui ne
sont pas liés à un projet spécifique. La trajectoire globale de l'utilisateur.

**Contenu type** : "J'ai décidé de prioriser startup-x plutôt que le side-project
pour les 3 prochains mois", "Changement de banque pro", "Décision de chercher
un nouvel appart", "Envie de faire du vlog dans les prochains mois".

Ce fichier est **distinct** du fait d'agréger dynamiquement les changelogs
par projet. Le global changelog capture des choses qui n'existent dans aucun
projet — les intentions, les pivots de vie, les décisions meta.

---

### `inbox/` — Le Sas de Confirmation

**Rôle** : réceptacle pour tout ce qui arrive et que l'agent ne peut pas router
avec certitude. Cette donnée est mise en attente — elle n'est ni perdue ni
rangée n'importe où.

**Flow** :
1. Donnée reçue — l'agent tente un routing
2. Si ambiguïté trop forte → crée un fichier dans `inbox/` avec analyse
3. L'utilisateur est notifié (via interface ou autre channel)
4. L'utilisateur voit le fichier inbox : contenu + analyse de l'agent +
   routing proposé + raisonnement
5. L'utilisateur confirme ou corrige (pas de description from scratch —
   il confirme/corrige un routing déjà tenté)
6. Le maintenance agent exécute, route la donnée, met à jour les fichiers
   concernés, supprime le fichier inbox, met à jour overview

**Format d'un fichier inbox** :
```markdown
---
created: 2025-07-14T16:42:00
type: vocal
status: pending
---

## Source
Vocal reçu le 14 juillet, 16:42. Durée : 45 secondes.

## Contenu
"Faut que je pense à appeler le comptable pour la TVA du Q3,
et aussi j'ai vu un appart sympa rue de Rivoli mais c'est au-dessus du budget."

## Analyse de l'agent
Deux informations détectées :
1. Appeler le comptable → tâche globale probable (ou liée à startup-x ?)
2. Appart rue de Rivoli → probablement lié au projet appart-search

## En attente de confirmation
```

**À propos du human review en général** : le review systématique de chaque
modification crée trop de friction — ça va à l'encontre de l'objectif. L'inbox
est le seul point de friction volontaire, et seulement quand l'ambiguïté est
réelle. Pour le reste, le maintenance agent agit et l'utilisateur peut toujours
voir ce qui a changé via un mécanisme de visibilité (à définir, voir questions ouvertes).

---

### `bucket/` (global) — Les Données Brutes

**Décision clé** : le bucket est **global**, pas par projet. Chaque item du
bucket est un fichier markdown individuel avec du frontmatter YAML.

**Pourquoi global** : si le bucket est par projet, on doit router avant de
ranger — ce qui recrée le problème. Avec un bucket global, la donnée atterrit
d'abord. L'association projet se fait après, via le frontmatter — ou jamais,
si c'est un truc flottant qui n'appartient à aucun projet.

**Le cas clé** : tu n'as pas encore de projet sur "la mémoire IA" mais tu as
déjà 6 articles, 2 vocaux, et 3 screenshots dans le bucket qui concernent ce
sujet. Le jour où tu crées le projet, l'agent retrouve tout via le frontmatter.
Le search agent peut aussi te répondre "voilà ce que j'ai sur ce sujet dans le
bucket" même sans projet existant.

**Format d'un item bucket** :
```markdown
---
created: 2025-07-14T16:42:00
type: vocal
source: whatsapp
projects: [startup-x]
topics: [client, deadline, specs]
status: processed
---

# Meeting client — debrief vocal 14 juillet

[contenu transcrit et analysé]
```

**Le champ `projects`** est une liste. Un item peut être lié à :
- Zéro projet (flottant — aucun projet n'existe encore ou c'est vraiment général)
- Un projet
- Plusieurs projets

**Pas de fichier de liens dans le projet** : les projets ne maintiennent pas
un fichier qui liste leurs items bucket. Le search agent fait une requête
frontmatter : "donne-moi tous les items bucket où `projects` contient `startup-x`".
C'est une requête dynamique, pas un fichier à maintenir. Maintenir un fichier
de liens, c'est du double travail qui crée des incohérences.

**Types d'items bucket possibles** : vocal transcrit, email converti, PDF
analysé, screenshot avec OCR/description, image, note rapide, lien + résumé,
screenshot de conversation WhatsApp analysé, photo prise dans la rue.

---

### `projects/<nom>/description.md` — L'Identité du Projet

**Rôle** : ce qu'est le projet, pourquoi il existe, quelle est la vision,
quel est le scope, quelles sont les contraintes fondamentales.

**Fréquence de modification** : rare. Ce fichier change quand le projet pivote
fondamentalement, pas à chaque évolution. C'est le fichier qu'un nouvel
intervenant lirait pour comprendre de quoi on parle.

**Mode d'édition** : réécriture complète quand nécessaire (le fichier est
court, la réécriture est acceptable et produit un document plus cohérent
qu'un patchwork d'éditions).

---

### `projects/<nom>/state.md` — La Photo Instantanée

**Rôle** : l'état du projet à cet instant. Volatile par nature — il est mis
à jour très fréquemment.

**Contenu** : statut global (actif / en pause / bloqué / terminé), focus actuel
(sur quoi on travaille exactement maintenant), ce qui est validé, ce qui bloque,
deadlines en cours, dernière mise à jour.

**Mode d'édition** : chirurgical. Format à sections claires et adressables.
Le maintenance agent modifie les sections spécifiques, ne réécrit pas tout.
Exemple : il met à jour uniquement la section "Ce qui bloque" quand un blocage
est levé.

---

### `projects/<nom>/tasks.md` — La Todo Vivante

**Rôle** : liste des tâches spécifiques à ce projet.

**Format** : identique au `tasks.md` global. Sections par statut (En cours /
À faire / Fait / Abandonné). Chaque tâche a une priorité et une date d'ajout.
Optionnellement : une date d'échéance et un lien vers la décision qui l'a
générée dans le changelog.

**Mode d'édition** : chirurgical. Déplacer une tâche d'une section à l'autre,
changer une priorité, en ajouter une, en déprecier une — tout ça sans réécrire
le fichier.

---

### `projects/<nom>/changelog.md` — Historique et Décisions

**Décision clé** : changelog et decisions sont **unifiés en un seul fichier**.
Le moins de fichiers à maintenir, le mieux. Un seul fichier chronologique
avec deux types d'entrées.

**Pourquoi unifier** : les décisions sont des événements. Un événement peut
porter du raisonnement. Séparer les deux crée un problème de "où est-ce que
je mets ça ?" — et multiplier les fichiers, c'est multiplier la charge de
maintenance.

**Format** :
```markdown
---
project: startup-x
updated: 2025-07-14T18:30:00
---

## 2025-07-14
- Specs reçues du client, version 2.1
- Réunion avec Marie — maquettes validées sans modification
- [décision] Abandon de l'API externe, build in-house
  → Le prestataire ne peut pas livrer avant juin. Notre deadline est mars.
    Impact : tâches d'intégration supprimées, nouvelles tâches backend créées.

## 2025-07-12
- Email client reçu avec changement de scope sur le module de paiement
- [décision] On absorbe le changement de scope sans renégocier le prix
  → Changement estimé à 3 jours de dev. Le client est un compte stratégique.
    Impact : date de livraison inchangée, on serre le planning sur module auth.
```

Entrées normales = faits. Entrées `[décision]` = faits + bloc de raisonnement
indenté en dessous. Le search agent peut filtrer les `[décision]` si besoin.
Le maintenance agent sait exactement comment formatter chaque type.

**Mode d'édition** : principalement append (ajout d'entrées sous la bonne
date). Parfois mise à jour d'une décision précédente si elle est renversée
(ajout d'une nouvelle entrée qui référence l'ancienne, jamais suppression).

---

## Principes de Design des Fichiers

**Règle fondamentale** : tout fichier fréquemment édité partiellement doit
avoir un format prévisible avec des ancres claires. Des headers markdown,
des sections nommées, des délimiteurs consistants.

**Pourquoi** : l'edit tool chirurgical du maintenance agent doit pouvoir
adresser des sections précises. "Insère cette entrée sous `## 2025-07-14`
dans le changelog", "déplace cette ligne de `## En cours` vers `## Fait`
dans tasks.md". Sans ancres claires, l'edit tool ne peut pas travailler.

**YAML frontmatter** : tous les fichiers ont du frontmatter. Minimum :
`created`, `updated`. Selon le type : `type`, `projects`, `topics`, `status`,
`priority`. Ce frontmatter est le deuxième niveau d'indexation (après la
position dans le file tree). Il permet des recherches par date, par projet,
par topic, par statut.

**Taille et granularité** :
- Les fichiers per-projet (tasks, changelog, state) peuvent grossir. C'est
  acceptable. L'edit chirurgical les maintient sans réécritures complètes.
- Si un fichier devient trop gros pour la search sémantique, le format
  structuré (entrées datées, sections nommées) compense — on cherche par
  date ou keyword plutôt que par sémantique pure.
- La stratégie d'archivage (ex: déplacer les tâches terminées dans un fichier
  `archive.md`) n'est pas encore définie mais est possible sans changer la
  structure.

---

## Le Routing des Données Entrantes

Trois niveaux, dans l'ordre :

**Niveau 1 — Inférence par contenu** : la donnée contient assez de signal
sémantique pour que l'agent route sans demander. "Le client de la startup
veut changer de prestataire" → `bucket/` avec `projects: [startup-x]`.
L'agent route, l'utilisateur n'est pas dérangé.

**Niveau 2 — Inférence par contexte conversationnel** : si l'utilisateur
est en train de parler d'un projet spécifique dans le chat et drop un fichier,
le contexte conversationnel suffit. Pas besoin de demander.

**Niveau 3 — Question minimale** : quand aucun signal n'est assez fort.
L'agent ne pose pas une question ouverte ("décris-moi ce que c'est"). Il
propose un routing et demande une confirmation. "Ce vocal semble lié à
appart-search. C'est bien ça ?" Oui/non avec correction.

**Filet de sécurité** : si vraiment l'utilisateur ne veut pas répondre
maintenant, la donnée va dans `inbox/` et le maintenance agent y reviendra.
Rien n'est perdu.

---

## Questions Ouvertes — À Traiter dans des Sessions Futures

### 1. Visibilité sur l'évolution de la mémoire (PRIORITÉ HAUTE)
L'utilisateur veut pouvoir voir comment sa knowledge base évolue. Si l'agent
fait des modifications en continu, comment l'utilisateur garde le contrôle
et la confiance ?

Options non tranchées :
- **Git history** : chaque modification du file tree est commitée automatiquement.
  L'utilisateur peut ouvrir le repo et voir les diffs. Simple, gratuit, universel.
- **Meta-log** : un fichier `memory-log.md` qui trace les modifications
  effectuées par les agents (quoi a changé, quand, pourquoi). Lisible dans
  l'interface.
- **Interface dédiée** : l'interface montre un feed des changements récents
  avec possibilité de voir les diffs et de revenir en arrière.

Ces options ne sont pas mutuellement exclusives. À débattre.

### 2. Mécanismes de Search (SESSION DÉDIÉE)
On sait ce qu'on veut : search par date, sémantique, keyword, grep.
On n'a pas défini comment ça se matérialise techniquement.

Éléments déjà posés :
- YAML frontmatter = indexation par date et métadonnées, gratuite dans la structure
- File tree = premier niveau d'indexation (projet, type de fichier)
- Format structuré des fichiers = chunking naturel par entrée/section
- Modèles pas chers avec grand context window = on peut charger beaucoup en contexte

Questions non tranchées :
- Est-ce qu'on fait un index Sqlite/BM25 ou est-ce que grep + frontmatter suffit ?
- Quand est-ce qu'on joue les embeddings vectoriels et quand est-ce qu'on s'en passe ?
- Comment le search agent décide quel outil utiliser selon la question posée ?
- Comment les agents sont équipés en tools de façon concrète ?

### 3. Flow Complet End-to-End (À DÉROULER)
On n'a pas encore tracé le flux complet de bout en bout :
"L'utilisateur envoie un vocal" → jusqu'à "tous les fichiers impactés
sont mis à jour et l'utilisateur peut voir ce qui a changé".

Étapes à définir précisément :
- Réception et transcription du vocal
- Quel agent prend la main en premier ?
- Comment le maintenance agent décide quels fichiers mettre à jour ?
- Dans quel ordre les fichiers sont-ils mis à jour ?
- Comment l'overview est-il régénéré ?
- Quand et comment l'utilisateur est-il notifié ?

### 4. Scaling de l'Overview à 45+ Projets
Le format actuel de l'overview (liste de projets avec statut en une ligne)
fonctionne à 5-10 projets. À 45, la question est ouverte.

Options non tranchées :
- Groupement/catégorisation dans l'overview (projets pro / perso / en pause...)
- Overview tronqué à 10 projets actifs + "voir tout" pour le reste
- L'overview ne liste que les projets avec activité récente (30 derniers jours)
- L'overview reste complet mais l'interface permet de filtrer

### 5. Politique de Taille et Archivage
Les fichiers de changelog et tasks vont grossir avec le temps. On sait que
ça peut poser des problèmes pour la search sémantique. On n'a pas défini
de politique d'archivage.

Questions non tranchées :
- Au bout de combien de lignes/mois on archive ?
- Comment ça se passe concrètement — fichier `changelog-archive-2025.md` ?
- Qui décide d'archiver — l'agent automatiquement ou l'utilisateur ?
- Les archives sont-elles incluses dans la search ou exclues par défaut ?

### 6. Voice-First — Détails d'Implémentation
La voix est mentionnée comme must-have. On n'a pas discuté de comment
ça s'intègre techniquement.

Questions non tranchées :
- Transcription locale ou API externe ?
- Le vocal transcrit va toujours dans le bucket avant d'être traité ?
- Comment on gère les vocaux très courts ("note rapide : rappeler Marie demain") ?

### 7. Interface
Mentionnée comme importante mais pas encore dans le scope immédiat.
Ce qu'on sait :
- Style Railway — propre, moderne, section fichiers à gauche, contenu au centre
- Chat global intégré
- Visibilité sur l'inbox
- Visibilité sur les changements récents

Ce qui n'est pas défini :
- Stack technique
- Mobile ou desktop first ?
- Est-ce que l'interface est une view sur le file tree ou quelque chose de plus abstrait ?

### 8. MCP / Skills / Intégrations
Le file tree doit être exportable et pluggable ailleurs.
Mentionné comme architecture cible mais pas encore discuté en détail.

Questions non tranchées :
- Comment un skill MCP expose-t-il le contexte projet à ChatGPT ou Claude ?
- Est-ce que c'est un export markdown statique ou une API dynamique ?
- Comment gère-t-on l'auth si le file tree est exposé via MCP ?

---

## État du File Tree à ce Stade

```
vault/
├── overview.md              ← Dashboard vivant | 50-80 lignes | réécrit
├── profile.md               ← Identité & préférences durables | édité chirurgie
├── tasks.md                 ← Tâches orphelines | format structuré | édité chirurgie
├── changelog.md             ← Événements/décisions globaux | append principalement
├── inbox/                   ← Données non routées | en attente utilisateur
│   └── vocal-2025-07-14.md
├── bucket/                  ← Données brutes | 1 fichier par item | frontmatter
│   ├── vocal-2025-07-14-meeting.md      → projects: [startup-x]
│   ├── email-2025-07-12-specs.md        → projects: [startup-x]
│   ├── article-2025-07-10-ai-memory.md  → projects: []
│   └── screenshot-2025-07-09-review.md → projects: [startup-x, appart-search]
│
└── projects/
    ├── startup-x/
    │   ├── description.md   ← Vision & scope | réécrit quand pivot
    │   ├── state.md         ← Photo instantanée | édité chirurgie | très fréquent
    │   ├── tasks.md         ← Todo vivante | édité chirurgie | fréquent
    │   └── changelog.md     ← Historique + décisions unifiés | append + édition
    │
    └── appart-search/
        ├── description.md
        ├── state.md
        ├── tasks.md
        └── changelog.md
```

---

## Ce qui est Tranché — Résumé Express

| Sujet | Décision |
|-------|----------|
| Decisions vs changelog | Unifiés en un seul fichier par projet |
| Bucket global vs par projet | Global. Items liés aux projets via frontmatter |
| Folder de tâches vs fichier unique | Fichier unique |
| Mode d'édition | Chirurgical (pas de réécriture complète sauf description.md) |
| Human review systématique | Non — trop de friction. Inbox uniquement quand ambiguïté |
| Modèles pour les agents | Pas chers, rapides, grand context window (120-130k) |
| YAML frontmatter | Oui sur tous les fichiers |
| Overview | 50-80 lignes, réécrit, premier fichier lu par les deux agents |
| Liens bucket → projet | Via frontmatter `projects:`, pas via fichier de liens dans le projet |

---

*Prochain point d'entrée : choisir une des questions ouvertes et l'attaquer.*
*Candidats les plus bloquants : le flow end-to-end (#3) et les mécanismes
de search (#2), car ils impactent le design de ce qui existe déjà.*